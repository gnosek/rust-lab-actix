//! A sample web app with a Redis data store
use crate::storage::redis::RedisStorage;
use crate::storage::{Todo, TodoStore};
use actix_web::http::StatusCode;
use actix_web::web::{Data, ServiceConfig};
use actix_web::{web, HttpResponse, Responder, ResponseError, Result};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

/// Pluggable storage backend implementations
mod storage;

/// Implement [`actix_web::ResponseError`] for the error returned by the storage engine
///
/// Since we don't override any default methods, the error will get sent as a HTTP 500 error code
/// with its string representation (as rendered by [`std::fmt::Display`]) as the message.
///
/// *Note*: the IntelliJ Rust plugin cannot detect that [`storage::TodoError'] implements
/// [`std::fmt::Display`] (since the implementation is generated by a procedural macro
/// and support for these is still incomplete in the plugin.
impl ResponseError for storage::TodoError {}

/// The simplest possible Actix handler
///
/// Takes no arguments and returns a `&static str`
async fn index() -> impl Responder {
    "Hello, world!"
}

/// List all entries from the data store
///
/// This function is generic and can take any type that implements [`TodoStore`]
///
/// The store itself comes from application data (i.e. is shared across all requests)
/// The return value is either a map of [`usize`] -> [`Todo`] (wrapped in [`web::Json`]
/// to indicate that we want it to be serialized as JSON), or an [`actix_http::error::Error`].
///
/// [`TodoStore::list`] returns a TodoError. It gets converted to the Actix error type
/// via a blanket implementation of [`From`] in [`actix_http::error`]:
/// ```
/// impl<T: ResponseError + 'static> From<T> for Error { ... }
/// ```
///
/// *Note*: the actual conversion is requested by the `?` operator. Expanded, the first line
/// might look like this:
/// ```
/// let todos = match store.list().await {
///     Ok(ok_val) => ok_val,
///     Err(err_val) => return actix_http::error::Error::from(err_val),
/// }
/// ```
/// ### Example
/// ```shell
/// http localhost:8080/todo"
/// ```
///
/// ### Example response
/// ```json
/// {
///     "1": {
///         "status": "Pending",
///         "title": "Learn Rust"
///     }
/// }
/// ```
async fn list<S: TodoStore>(store: web::Data<S>) -> Result<web::Json<BTreeMap<usize, Todo>>> {
    let todos = store.list().await?;
    Ok(web::Json(todos))
}

/// A request to the [`create`] endpoint
///
/// Since we only want a single field in the JSON body, this struct has that one field
/// For production code, only [`Deserialize`] is needed for request types, but [`Serialize`]
/// is useful for testing (generating requests instead of handling them)
///
/// The title field is required. An optional field might be e.g. an `Option<String>`,
/// which would be `Some(title)` if the field was present in the request and `None` otherwise.
#[derive(Serialize, Deserialize)]
struct CreateRequest {
    title: String,
}

/// A response of the [`create`] endpoint
///
/// Only [`Serialize`] is required to generate the response, but [`Deserialize`] is useful for
/// testing
#[derive(Serialize, Deserialize)]
struct CreateResponse {
    todo_id: usize,
}

/// Create a new todo entry
///
/// In addition to a reference to the data store, we need the request body
/// parsed according to our specification (i.e. a single `title` field)
///
/// *Note*: we cannot even call this function without having a valid [`CreateRequest`],
/// so it can assume that the request is valid, at least on the syntactic level
/// (otherwise the [`web::Json`] extractor would return an HTTP 400 error).
///
/// *Note*: See [`list`] for the discussion of the generic parameter and the result type.
///
/// ### Example
/// ```shell
/// http localhost:8080/todo title="Learn Rust"
/// ```
///
/// ### Example response
/// ```json
/// {
///     "todo_id": 1
/// }
/// ```
async fn create<S: TodoStore>(
    store: web::Data<S>,
    req: web::Json<CreateRequest>,
) -> Result<web::Json<CreateResponse>> {
    let todo = Todo::new(req.title.clone());
    let todo_id = store.create(todo).await?;
    Ok(web::Json(CreateResponse { todo_id }))
}

/// Mark a todo entry as done
///
/// Returns HTTP 204 (No Content) if the entry was marked successfully or 404 (Not Found)
/// if the todo_id was invalid.
///
/// Since we want to influence the HTTP code of the response, the easiest way is to
/// return an [`HttpResponse`] directly.
///
/// We don't send any response body in either case so just a call to [`HttpResponse::new`]
/// is enough.
///
/// *Note*: See [`list`] for the discussion of the generic parameter and the result type.
///
/// ### Example
///
/// ```shell
/// http POST localhost:8080/todo/1/done
/// ```
async fn mark_done<S: TodoStore>(
    store: web::Data<S>,
    todo_id: web::Path<usize>,
) -> Result<HttpResponse> {
    let updated = store.mark_done(*todo_id).await?;

    if updated {
        Ok(HttpResponse::new(StatusCode::NO_CONTENT))
    } else {
        Ok(HttpResponse::new(StatusCode::NOT_FOUND))
    }
}

/// Delete a todo entry
///
/// Returns HTTP 204 (No Content) if the entry was successfully deleted or 404 (Not Found)
/// if the todo_id was invalid.
///
/// Since we want to influence the HTTP code of the response, the easiest way is to
/// return an [`HttpResponse`] directly.
///
/// We don't send any response body in either case so just a call to [`HttpResponse::new`]
/// is enough.
///
/// *Note*: See [`list`] for the discussion of the generic parameter and the result type.
///
/// ### Example
///
/// ```shell
/// http DELETE localhost:8080/todo/1
/// ```
async fn delete<S: TodoStore>(
    store: web::Data<S>,
    todo_id: web::Path<usize>,
) -> Result<HttpResponse> {
    let updated = store.delete(*todo_id).await?;

    if updated {
        Ok(HttpResponse::new(StatusCode::NO_CONTENT))
    } else {
        Ok(HttpResponse::new(StatusCode::NOT_FOUND))
    }
}

/// A helper function to configure the application with different data stores
///
/// Functions returning [`actix_web::App`] instances are not supported by Actix (some types
/// required to express the signature aren't public). The recommended way is to use
/// [`actix_web::App::configure`], which takes as a parameter a function which receives
/// a `&mut` [`ServiceConfig`]. The service config object can be configured like an App instance.
///
/// To simply modularize the application routes, you can define a function and pass it to
/// `App::configure`:
/// ```
/// fn some_app(cfg: &mut ServiceConfig) {
///     cfg.route(...)
///         .route(...)
/// }
///
/// HttpServer::new(move || App::new().configure(some_app) ...)
/// ```
///
/// In our case, we also want to inject a specific data store into the application. This has two
/// consequences:
/// 1. Methods interacting with the data store need an explicit template parameter (it has to be
/// known statically)
/// 2. The data store itself is injected as service data ([`actix_web::App::data`]), so handlers
/// can use a [`web::Data`] extractor that returns the store instance (wrapped in
/// an [`std::sync::Arc`])
fn todo_app<S: TodoStore + 'static>(store: S) -> impl FnOnce(&mut ServiceConfig) {
    move |cfg: &mut ServiceConfig| {
        cfg.route("/", web::get().to(index))
            .route("/todo", web::get().to(list::<S>))
            .route("/todo", web::post().to(create::<S>))
            .route("/todo/{todo_id}/done", web::post().to(mark_done::<S>))
            .route("/todo/{todo_id}", web::delete().to(delete::<S>))
            .app_data(Data::new(store));
    }
}

/// The entry point of the application
#[actix_web::main]
async fn main() -> storage::Result<()> {
    use actix_web::{App, HttpServer};

    // use the Redis storage. Since our request handlers are generic,
    // they can take any type that implements [`TodoStore`]
    let store = RedisStorage::new("redis://127.0.0.1:6379").await?;

    HttpServer::new(move || App::new().configure(todo_app(store.clone())))
        .bind("127.0.0.1:8080")?
        .run()
        .await?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::storage::memory::MemoryStorage;
    use crate::storage::{Todo, TodoStatus};
    use crate::{todo_app, CreateRequest, CreateResponse};
    use actix_http::Request;
    use actix_web::dev::{Service, ServiceResponse};
    use actix_web::body::BoxBody;
    use actix_web::{test, App, Error};
    use serde::de::DeserializeOwned;
    use serde::Serialize;
    use std::collections::BTreeMap;
    use std::str;
    use std::sync::Arc;

    async fn test_app() -> impl Service<Request, Response = ServiceResponse<BoxBody>, Error = Error> {
        let store = Arc::new(MemoryStorage::default());

        test::init_service(App::new().configure(todo_app(store.clone()))).await
    }

    async fn get_string(
        app: impl Service<Request, Response = ServiceResponse<BoxBody>, Error = Error>,
        uri: &str,
    ) -> String {
        let req = test::TestRequest::get().uri(uri).to_request();
        let resp = test::call_and_read_body(&app, req).await;
        String::from_utf8(resp.to_vec()).unwrap()
    }

    async fn get_json<Resp>(
        app: impl Service<Request, Response = ServiceResponse<BoxBody>, Error = Error>,
        uri: &str,
    ) -> Resp
    where
        Resp: DeserializeOwned,
    {
        let req = test::TestRequest::get().uri(uri).to_request();
        test::call_and_read_body_json(&app, req).await
    }

    async fn post(
        app: impl Service<Request, Response = ServiceResponse<BoxBody>, Error = Error>,
        uri: &str,
    ) {
        let req = test::TestRequest::post().uri(uri).to_request();

        test::call_and_read_body(&app, req).await;
    }

    async fn delete(
        app: impl Service<Request, Response = ServiceResponse<BoxBody>, Error = Error>,
        uri: &str,
    ) {
        let req = test::TestRequest::delete().uri(uri).to_request();

        test::call_and_read_body(&app, req).await;
    }

    async fn post_json<Req, Resp>(
        app: impl Service<Request, Response = ServiceResponse<BoxBody>, Error = Error>,
        uri: &str,
        body: &Req,
    ) -> Resp
    where
        Req: Serialize,
        Resp: DeserializeOwned,
    {
        let req = test::TestRequest::post()
            .uri(uri)
            .set_json(body)
            .to_request();

        test::call_and_read_body_json(&app, req).await
    }

    async fn create_todo(
        app: impl Service<Request, Response = ServiceResponse<BoxBody>, Error = Error>,
        title: &str,
    ) -> usize {
        let req = CreateRequest {
            title: title.to_string(),
        };
        let resp: CreateResponse = post_json(&app, "/todo", &req).await;
        resp.todo_id
    }

    #[actix_rt::test]
    async fn test_index() {
        let app = test_app().await;

        let resp = get_string(app, "/").await;
        assert_eq!(resp, "Hello, world!")
    }

    #[actix_rt::test]
    async fn test_list_empty_string() {
        let mut app = test_app().await;
        assert_eq!(get_string(&mut app, "/todo").await, "{}");
    }

    #[actix_rt::test]
    async fn test_list_empty() {
        let mut app = test_app().await;
        let todos: BTreeMap<usize, Todo> = get_json(&mut app, "/todo").await;
        assert!(todos.is_empty());
    }

    #[actix_rt::test]
    async fn test_create() {
        let mut app = test_app().await;

        assert_eq!(create_todo(&mut app, "testing").await, 1);
        assert_eq!(create_todo(&mut app, "testing again").await, 2);
    }

    #[actix_rt::test]
    async fn test_create_and_list() {
        let mut app = test_app().await;

        create_todo(&mut app, "testing").await;
        let todos: BTreeMap<usize, Todo> = get_json(&mut app, "/todo").await;

        let actual: Vec<_> = todos.into_iter().collect();
        let expected = vec![(1, Todo::new("testing".to_string()))];

        assert_eq!(expected, actual);
    }

    #[actix_rt::test]
    async fn test_mark_done() {
        let mut app = test_app().await;

        create_todo(&mut app, "testing").await;
        post(&mut app, "/todo/1/done").await;
        let todos: BTreeMap<usize, Todo> = get_json(&mut app, "/todo").await;

        let the_todo = todos.get(&1).unwrap();
        assert_eq!(the_todo.get_status(), TodoStatus::Done);
    }

    #[actix_rt::test]
    async fn test_delete() {
        let mut app = test_app().await;

        create_todo(&mut app, "testing").await;
        delete(&mut app, "/todo/1").await;
        let todos: BTreeMap<usize, Todo> = get_json(&mut app, "/todo").await;
        assert!(todos.is_empty());
    }
}
